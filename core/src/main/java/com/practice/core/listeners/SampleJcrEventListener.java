
package com.practice.core.listeners;

import org.apache.jackrabbit.api.observation.JackrabbitEvent;
import org.apache.jackrabbit.commons.webdav.EventUtil;
import org.apache.sling.jcr.api.SlingRepository;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.event.EventAdmin;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.practice.core.models.impl.OsgiConfigImpl.ServiceConfig;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.observation.Event;
import javax.jcr.observation.EventIterator;
import javax.jcr.observation.EventListener;
import javax.jcr.observation.ObservationManager;
import java.util.Dictionary;
import java.util.Hashtable;
import java.util.Map;


@Component(
        name = "ACS AEM Samples - JCR Event Listener",
        properties = "Sample implementation of a low-level JCR Event Listener.",

        // One of the few cases where immediate = true; this is so the Event Listener starts listening immediately
        immediate = true
)
@ServiceConfig

/**
 * NOTE: YOU ALMOST NEVER WANT TO USE JCR EVENT LISTENERS; USE SLING EVENT LISTENERS INSTEAD!
 */

public class SampleJcrEventListener implements EventListener {
    private static final Logger log = LoggerFactory.getLogger(SampleJcrEventListener.class);

    /*
     * A combination of one or more event type constants encoded as a bitmask
     *
     * Available JCR Events:
     *
     * Event.NODE_ADDED
     * Event.NODE_MOVED
     * Event.NODE_REMOVED
     * Event.PERSIST
     * Event.PROPERTY_ADDED
     * Event.PROPERTY_REMOVED
     * Event.PROPERTY_CHANGED
    */
    private final int events = Event.PROPERTY_ADDED | Event.NODE_ADDED;

    // Only events whose associated node is at absPath (or within its subtree, if isDeep is true) will be received.
    // It is permissible to register a listener for a path where no node currently exists.
    private final String absPath = "/content/samples";
    private final boolean isDeep = true;

    // If noLocal is true, events generated by the session through which the listener was registered are ignored.
    // Otherwise, they are not ignored.
    private final boolean noLocal = false;

    private final String[] uuids = null;

    // Only events whose associated node has one of the node types (or a subtype of one of the node types) in this list will be received. If his parameter is null then no node type-related restriction is placed on events received.
    private final String[] nodeTypes = new String[]{"nt:unstructured", "nt:folder"};

    // This is one of the VERY FEW times that a JCR Session is appropriate in an OSGi Services instance var space
    // This must be left open for the life of the Event Listener as this is the security context that scopes what
    // events this listener can see.
    private Session observationSession = null;


    @org.osgi.service.component.annotations.Reference
    private SlingRepository repository;

    @org.osgi.service.component.annotations.Reference
    private EventAdmin eventAdmin;

    @Override
    public void onEvent(final EventIterator events) {
        // Handle events
        while (events.hasNext()) {
            try {
                Event event = events.nextEvent();

                if (event instanceof JackrabbitEvent && ((JackrabbitEvent) event).isExternal()) {

                    return;
                } else {
                }

                final String path = event.getPath();

                if (Event.NODE_ADDED == event.getType()) {
                    // Node added!
                } else if (Event.PROPERTY_ADDED == event.getType()) {
                    // Property added!
                }

                // Dummy variable; You'd never conditionally pick the approach in real code.
                boolean handleAsJcrEvent = true;

                if (handleAsJcrEvent) {
                    // Execute handler logic in this event handler...

                    // Make sure you handle this quickly else your event handler may get blacklisted!

                    // Get a resourceResolver or JCR Session using the usual ways
                    // Always make sure to close them if you open them though!

                    // ... do some work
                } else {
                    // Alternatively to doing work in the event, you can kick off a new Sling Event OR Job

                    // Example of kicking off a Sling Event which will then pick up and do the work via a Sling Event
                    // Listener; Generally this can be simply avoided by making a Sling Event Handler directly.

                    final Dictionary<String, Object> eventProperties = new Hashtable<String, Object>();
                    eventProperties.put("resourcePath", path);
                    eventAdmin.postEvent(new org.osgi.service.event.Event(EventUtil.EVENT_PROPERTYADDED, eventProperties));
                }

            } catch (RepositoryException ex) {
                log.error("Something bad happened!", ex);
            }
        }
    }

    
    }

